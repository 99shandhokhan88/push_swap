# push_swap

"push_swap" is a computer science project that challenges students to create an algorithm in the C programming language. The objective is to sort a randomly ordered list of numbers in two stacks (Stack A and Stack B) using a limited set of predefined actions, such as swapping elements, rotating the stacks, and pushing elements between the stacks. The main goal of the project is to sort the numbers in Stack A with the fewest possible actions. Students must devise efficient sorting strategies to accomplish this within the project's action limit.

Here's my roadmap for "push_swap" project, broken down into a 20-day schedule based on my experience:

## Day 1 - Day 4: Understanding the Project and Problem**

I read the subject and I asked some of my peers for help. I spend the first few days fully understanding the requirements and constraints of the "push_swap" project. I made sure I'm comfortable with the allowed actions: sa, sb, ss, ra, rb, rr, rra, rrb, rrr, pa, and pb. I reviewed the provided strategies for handling 3 random numbers and 5 random numbers, as they serve as the foundation for larger cases. After that I searched some infos on the web finding those resources:
https://medium.com/@ayogun/push-swap-c1f5d2d41e97
https://www.youtube.com/watch?v=OaG81sDEpVk
https://www.youtube.com/watch?v=7h1s2SojIRw
https://www.youtube.com/watch?v=XE4VP_8Y0BU
https://www.youtube.com/watch?v=-qOVVRIZzao
https://push_swap.simple.ink/
https://medium.com/@jamierobertdawson/push-swap-the-least-amount-of-moves-with-two-stacks-d1e76a71789a
https://www.youtube.com/watch?v=XE4VP_8Y0BU
https://www.youtube.com/watch?v=JPyuH4qXLZ0
https://medium.com/human-in-a-machine-world/quicksort-the-best-sorting-algorithm-6ab461b5a9d0
https://en.wikipedia.org/wiki/Longest_increasing_subsequence#:~:text=In%20computer%20science%2C%20the%20longest,not%20necessarily%20contiguous%2C%20or%20unique
https://stackoverflow.com/questions/330793/how-to-initialize-a-struct-in-accordance-with-c-programming-language-standards
https://koor.fr/C/cstdlib/exit.wp
https://www.rapidtables.com/code/linux/gcc/gcc-g.html
https://www.youtube.com/watch?v=e_l77X9P1H4
https://mycareerwise.com/programming/category/sorting/quick-sort-using-recursion
https://www.geeksforgeeks.org/worst-average-and-best-case-analysis-of-algorithms/?ref=lbp
https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_quick_sort.htm
https://www.geeksforgeeks.org/introduction-to-algorithms/?ref=lbp
https://en.wikipedia.org/wiki/Analysis_of_algorithms
https://liacs.leidenuniv.nl/~rijnjnvan/ds2013/assets/opdrachten/opdracht1-stacksorting.pdf
https://www.educba.com/sorting-in-c/
https://www.geeksforgeeks.org/quick-sort/
https://www.programiz.com/c-programming/c-structures
https://www.jesuisundev.com/comprendre-la-notation-big-o-en-7-minutes/#:~:text=C%27est%20quoi%20la%20notation,l%27efficacitÃ©%20de%20ton%20code.
https://www.freecodecamp.org/news/big-o-notation-why-it-matters-and-why-it-doesnt-1674cfa8a23c/
https://www.tutorialspoint.com/data_structures_algorithms/quick_sort_algorithm.htm
https://www.programiz.com/dsa/quick-sort
https://www.java67.com/2014/07/quicksort-algorithm-in-java-in-place-example.html
https://www.geeksforgeeks.org/an-introduction-to-flowcharts/
https://medium.com/nerd-for-tech/push-swap-tutorial-fa746e6aba1e
https://en.wikipedia.org/wiki/Insertion_sort
https://www.youtube.com/watch?v=kgBjXUE_Nwc
https://www.geeksforgeeks.org/longest-increasing-subsequence-dp-3/
https://www.calculatorsoup.com/calculators/statistics/random-number-generator.php
https://medium.com/@jamierobertdawson/push-swap-the-least-amount-of-moves-with-two-stacks-d1e76a71789a
https://www.geeksforgeeks.org/exit0-vs-exit1-in-c-c-with-examples/

After all this, considering that I pushed so_long and I had only 20 days until the end of November 2023, I find that the most fast, clear, pleasant and smart way for this project is to follow the guide of one of my friends at 42 called Lnicoter ----> https://github.com/NicoTerabyte/Push_swap/blob/main/Push_swap/english_guide.pdf










**Day 4 - Day 5: Implementation for 3 Random Numbers**

- Begin coding the sorting algorithm for 3 random numbers.
- Test your code with various scenarios and ensure it sorts the numbers correctly in a minimal number of actions (2 or less).

**Day 6 - Day 8: Implementation for 5 Random Numbers**

- Extend your code to handle 5 random numbers.
- Apply the logic mentioned for moving the first two numbers to Stack B and sort the rest in Stack A.
- Test your implementation thoroughly.

**Day 9 - Day 11: Implementation for 100 Random Numbers (Initial Approach)**

- Implement the sorting algorithm for 100 random numbers, initially using the Insertion Sort algorithm.
- Focus on getting the basic functionality working before optimization.

**Day 12 - Day 15: Optimization for 100 Random Numbers**

- Refine your code for 100 random numbers using the chunking strategy you outlined.
- Test and compare the efficiency of your optimized approach with the initial Insertion Sort method.
- Make sure it stays within the action limit of 12.

**Day 16 - Day 18: Implementation for 500 Random Numbers**

- Apply the optimized strategy for 100 random numbers to handle 500 random numbers.
- Make any necessary adjustments based on the larger dataset.

**Day 19 - Day 20: Testing and Fine-Tuning**

- Perform comprehensive testing with various input scenarios for all test cases: 3, 5, 100, and 500 random numbers.
- Fine-tune your code, making it more efficient and optimizing action usage.
- Debug any issues that arise during testing.

During the entire 20-day period, you should be actively using the push_swap visualizer tool to visualize and analyze the actions performed by your code, making it easier to spot any inefficiencies or errors.

This roadmap should help you make steady progress and successfully complete your "push_swap" project within the given time frame. If you encounter any challenges or need further assistance along the way, don't hesitate to seek help and guidance. Good luck with your project!
